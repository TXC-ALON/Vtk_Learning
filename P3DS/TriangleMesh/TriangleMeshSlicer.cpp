#include "TriangleMesh.hpp"
#include "ClipperUtils.hpp"
#include "SVG.hpp"
#include <float.h>

namespace Slic3r {

//=======================================================================================================
// TriangleMeshSlicer类定义
//=======================================================================================================

// 非实体的切片函数  输出是Polylines
template <Axis A>
void
TriangleMeshSlicer<A>::slice(const std::vector<float> &z, std::vector<Polylines>* layers, int threads) const
{
	if (z.size() == 0) {
		LOGINFO("【实体】切片层数为0，直接退出 \n");
		return;
	}
	if (this->mesh->stl.stats.number_of_facets == 0) {
		LOGINFO("【实体】mesh面片数为0，直接退出 \n");
		return;
	}

	LOGINFO("【非实体】切片线程数%d \n", threads);
	DWORD dwStart = GetTickCount();
	// 切片线段容器 layer_idx -> IntersectionLines
    std::vector<IntersectionLines> lines(z.size());
	// 计算z平面集合和模型所有三角面片的交线
    {
        boost::mutex lines_mutex;
        parallelize<int>(
            0,
            this->mesh->stl.stats.number_of_facets-1,
            boost::bind(&TriangleMeshSlicer<A>::_slice_do, this, _1, &lines, &lines_mutex, z),
			*this->worker_pp,
			threads
        );
    }
	LOGINFO("【非实体】计算交线 总耗时【%u】", GetTickCount() - dwStart);
	dwStart = GetTickCount();

	//SVG svg("IntersectionLines.svg");
	//svg.draw(lines[0]);
	//svg.Close();


	// 输出结果
	layers->resize(z.size());
	for (int i = 0; i<z.size(); i++)
	{
		// 取出当前层的切片数据
		IntersectionLines* p_Interlines = &(lines[i]);
		Polylines* p_polylines = &(layers->at(i));
		// 进行格式转换
		for (int j = 0; j< p_Interlines->size(); j++)
		{
			IntersectionLine* p_Interline = &(p_Interlines->at(j));
			Polyline temp_Polyline;
			temp_Polyline.points.push_back(p_Interline->a);
			temp_Polyline.points.push_back(p_Interline->b);
			p_polylines->push_back(temp_Polyline);
		}
	}
}

// 实体切片函数  输出是Polygons
template <Axis A>
void
TriangleMeshSlicer<A>::slice(const std::vector<float> &z, std::vector<Polygons>* layers, int threads) const
{
	/*
	This method gets called with a list of unscaled Z coordinates and outputs
	a vector pointer having the same number of items as the original list.
	Each item is a vector of polygons created by slicing our mesh at the
	given heights.

	This method should basically combine the behavior of the existing
	Perl methods defined in lib/Slic3r/TriangleMesh.pm:

	- analyze(): this creates the 'facets_edges' and the 'edges_facets'
	tables (we don't need the 'edges' table)

	- slice_facet(): this has to be done for each facet. It generates
	intersection lines with each plane identified by the Z list.
	The get_layer_range() binary search used to identify the Z range
	of the facet is already ported to C++ (see Object.xsp)

	- make_loops(): this has to be done for each layer. It creates polygons
	from the lines generated by the previous step.

	At the end, we free the tables generated by analyze() as we don't
	need them anymore.

	NOTE: this method accepts a vector of floats because the mesh coordinate
	type is float.
	*/

	if (z.size() == 0) {
		LOGINFO("【实体】切片层数为0，直接退出 \n");
		return;
	}
	if (this->mesh->stl.stats.number_of_facets == 0) {
		LOGINFO("【实体】mesh面片数为0，直接退出 \n");
		return;
	}

	LOGINFO("【实体】切片线程数%d \n", threads);
	DWORD dwStart = GetTickCount();
	// 切片线段容器 layer_idx -> IntersectionLines
	std::vector<IntersectionLines> lines(z.size());
	// 计算z平面集合和模型所有三角面片的交线
	{
		boost::mutex lines_mutex;
		parallelize<int>(
			0,
			this->mesh->stl.stats.number_of_facets - 1,
			boost::bind(&TriangleMeshSlicer<A>::_slice_do, this, _1, &lines, &lines_mutex, z),
			*this->worker_pp,
			threads
			);
	}
	LOGINFO("【实体】计算交线 总耗时【%u】", GetTickCount() - dwStart);
	dwStart = GetTickCount();

	// v_scaled_shared could be freed here
	// build loops
	layers->resize(z.size());
	LOGINFO("【实体】开始_make_loops_do");
	parallelize<size_t>(
		0,
		lines.size() - 1,
		boost::bind(&TriangleMeshSlicer<A>::_make_loops_do, this, _1, &lines, layers),
		*this->worker_pp,
		threads
		);
	LOGINFO("【实体】构建loops 总耗时【%u】", GetTickCount() - dwStart);
}

// 切片线程真正执行体
template <Axis A>
void
TriangleMeshSlicer<A>::_slice_do(size_t facet_idx, std::vector<IntersectionLines>* lines, boost::mutex* lines_mutex, 
    const std::vector<float> &z) const
{
	//LOGINFO("facet_idx = %d [begin]", facet_idx);
	// 取出该三角片
    const stl_facet &facet = this->mesh->stl.facet_start[facet_idx];
	if (
		_isnan(_x(facet.vertex[0])) != 0 ||
		_isnan(_y(facet.vertex[0])) != 0 || 
		_isnan(_z(facet.vertex[0])) != 0 || 
		_isnan(_x(facet.vertex[1])) != 0 ||
		_isnan(_y(facet.vertex[1])) != 0 ||
		_isnan(_z(facet.vertex[1])) != 0 ||
		_isnan(_x(facet.vertex[2])) != 0 ||
		_isnan(_y(facet.vertex[2])) != 0 ||
		_isnan(_z(facet.vertex[2])) != 0 
		)
	{
		LOGINFO("this facet has vertex nan value!");
		return;
	}
    
    // find facet extents 计算该三角片在z轴上的范围
    const float min_z = fminf(_z(facet.vertex[0]), fminf(_z(facet.vertex[1]), _z(facet.vertex[2])));
    const float max_z = fmaxf(_z(facet.vertex[0]), fmaxf(_z(facet.vertex[1]), _z(facet.vertex[2])));
    

    //LOGINFO("\n==> FACET %zu (%f,%f,%f - %f,%f,%f - %f,%f,%f):", facet_idx,
    //    _x(facet.vertex[0]), _y(facet.vertex[0]), _z(facet.vertex[0]),
    //    _x(facet.vertex[1]), _y(facet.vertex[1]), _z(facet.vertex[1]),
    //    _x(facet.vertex[2]), _y(facet.vertex[2]), _z(facet.vertex[2]));
    //LOGINFO("z: min = %.2f, max = %.2f", min_z, max_z);
    
    
	// 找出该三角面片所在的切片高度集合
    // find layer extents
    std::vector<float>::const_iterator min_layer, max_layer;
    min_layer = std::lower_bound(z.begin(), z.end(), min_z); // first layer whose slice_z is >= min_z
    max_layer = std::upper_bound(z.begin() + (min_layer - z.begin()), z.end(), max_z) - 1; // last layer whose slice_z is <= max_z
	//LOGINFO("layers: min = %d, max = %d\n", (int)(min_layer - z.begin()), (int)(max_layer - z.begin()));
    
    for (std::vector<float>::const_iterator it = min_layer; it != max_layer + 1; ++it) {
        std::vector<float>::size_type layer_idx = it - z.begin();
		if (this->is_nonsolid)
			this->slice_facet_nonsolid(*it / SCALING_FACTOR, facet, facet_idx, min_z, max_z, &(*lines)[layer_idx], lines_mutex);
		else
			this->slice_facet(*it / SCALING_FACTOR, facet, facet_idx, min_z, max_z, &(*lines)[layer_idx], lines_mutex);
    }
	//LOGINFO("facet_idx = %d [End]", facet_idx);
}

// 切片入口函数  输出是ExPolygons
template <Axis A>
void
TriangleMeshSlicer<A>::slice(const std::vector<float> &z, std::vector<ExPolygons>* layers, int threads) const
{
    std::vector<Polygons> layers_p;
    this->slice(z, &layers_p, threads);

	// layers 空间不够 补全不足空间并初始化 保留之前的数据
	if (layers->size() < z.size())
	{
		std::vector<ExPolygons> Add_layers;
		Add_layers.resize(z.size() - layers->size());
		layers->insert(layers->end(), Add_layers.begin(), Add_layers.end());
	}

	if (layers_p.size() == 0) {
		LOGINFO("【实体】make_expolygons layers_p.size() == 0 直接退出!");
		return;
	}

	// modify by DuYH 多线程实现
	LOGINFO("【实体】make_expolygons 线程数【%d】", threads);
	DWORD dwStart = GetTickCount();
	parallelize<size_t>(
		0,
		layers_p.size() - 1,
		boost::bind(&TriangleMeshSlicer<A>::_make_expolygons_do, this, _1, &layers_p, layers),
		*this->worker_pp,
		threads
		);
	LOGINFO("【实体】make_expolygons 总耗时【%u】", GetTickCount() - dwStart);
}

// 计算模型和某个特定的切平面z的切片  将结果ExPolygon中
template <Axis A>
void
TriangleMeshSlicer<A>::slice(float z, ExPolygons* slices, int threads) const
{
    std::vector<float> zz;
    zz.push_back(z);
    std::vector<ExPolygons> layers;
    this->slice(zz, &layers, threads);
    append_to(*slices, layers.front());
}

// 计算某个三角面片和sice_z平面相交的线段
template <Axis A>
void
TriangleMeshSlicer<A>::slice_facet(float slice_z, const stl_facet &facet, const int &facet_idx,
    const float &min_z, const float &max_z, std::vector<IntersectionLine>* lines,
    boost::mutex* lines_mutex) const
{
    std::vector<IntersectionPoint> points;  // 在切面上交点集和
    std::vector< std::vector<IntersectionPoint>::size_type > points_on_layer;// 顶点在切平面上集合
    bool found_horizontal_edge = false;
    
    /* reorder vertices so that the first one is the one with lowest Z
       this is needed to get all intersection lines in a consistent order
       (external on the right of the line) */
	/* 重新排列顶点，使第一个顶点为Z最小值
		这需要以一致的顺序得到所有的交集
		(在线的右边) */
    int i = 0;
    if (_z(facet.vertex[1]) == min_z) {
        // vertex 1 has lowest Z
        i = 1;
    } else if (_z(facet.vertex[2]) == min_z) {
        // vertex 2 has lowest Z
        i = 2;
    }
    for (int j = i; (j-i) < 3; j++) // 遍历该面片的三条边
	{  
		// loop through facet edges
        int edge_id = this->facets_edges[facet_idx][j % 3];
        int a_id = this->mesh->stl.v_indices[facet_idx].vertex[j % 3];
        int b_id = this->mesh->stl.v_indices[facet_idx].vertex[(j+1) % 3];
        stl_vertex* a = &this->v_scaled_shared[a_id];
        stl_vertex* b = &this->v_scaled_shared[b_id];
        
        if (_z(*a) == _z(*b) && _z(*a) == slice_z) // 当前边与切平面平行并且在平面上
		{
            // edge is horizontal and belongs to the current layer
            stl_vertex &v0 = this->v_scaled_shared[ this->mesh->stl.v_indices[facet_idx].vertex[0] ];
            stl_vertex &v1 = this->v_scaled_shared[ this->mesh->stl.v_indices[facet_idx].vertex[1] ];
            stl_vertex &v2 = this->v_scaled_shared[ this->mesh->stl.v_indices[facet_idx].vertex[2] ];
            IntersectionLine line;
            if (min_z == max_z) // 当前平面是水平的
			{
                line.edge_type = feHorizontal;
                if (_z(this->mesh->stl.facet_start[facet_idx].normal) < 0) // 该面片的法向量向下
				{
                    // if normal points downwards this is a bottom horizontal facet so we reverse its point order 
					// 如果法相点向下，这是一个底部水平面，所以我们颠倒它点的顺序
                    std::swap(a, b);
                    std::swap(a_id, b_id);
                }
            } 
			else if (_z(v0) < slice_z || _z(v1) < slice_z || _z(v2) < slice_z) // 另一个点在切平面之下 也要颠倒顺序
			{
                line.edge_type = feTop;
                std::swap(a, b);
                std::swap(a_id, b_id);
            }
			else // 另一个点在切平面之上
			{
                line.edge_type = feBottom;
            }
            line.a.x    = _x(*a);
            line.a.y    = _y(*a);
            line.b.x    = _x(*b);
            line.b.y    = _y(*b);
            line.a_id   = a_id;
            line.b_id   = b_id;
            if (lines_mutex != NULL)
			{
                boost::lock_guard<boost::mutex> l(*lines_mutex);
                lines->push_back(line);
            } 
			else
			{
                lines->push_back(line);
            }
            
            found_horizontal_edge = true;
            
            // if this is a top or bottom edge, we can stop looping through edges
            // because we won't find anything interesting
            if (line.edge_type != feHorizontal) //非水平面直接结束边循环  因为不会再有交点
				return;
        } 
		else if (_z(*a) == slice_z) // 该边不是水平边  但是有个顶点在切平面上 顶点就是交点
		{
            IntersectionPoint point;
            point.x         = _x(*a);
            point.y         = _y(*a);
            point.point_id  = a_id;
            points.push_back(point);
            points_on_layer.push_back(points.size()-1);
        } 
		else if (_z(*b) == slice_z) 
		{
            IntersectionPoint point;
            point.x         = _x(*b);
            point.y         = _y(*b);
            point.point_id  = b_id;
            points.push_back(point);
            points_on_layer.push_back(points.size()-1);
        } 
		else if ((_z(*a) < slice_z && _z(*b) > slice_z) || (_z(*b) < slice_z && _z(*a) > slice_z)) // 该边被切平面切割  计算交点
		{
            // edge intersects the current layer; calculate intersection
            
            IntersectionPoint point;
            point.x         = _x(*b) + (_x(*a) - _x(*b)) * (slice_z - _z(*b)) / (_z(*a) - _z(*b));
            point.y         = _y(*b) + (_y(*a) - _y(*b)) * (slice_z - _z(*b)) / (_z(*a) - _z(*b));
            point.edge_id   = edge_id;
            points.push_back(point);
        }
    }
	// 边循环结束

    if (found_horizontal_edge)  // 发现水平边和切片面重合 退出 
		return;
    
    if (!points_on_layer.empty()) // 有顶点在切平面上
	{
        // we can't have only one point on layer because each vertex gets detected
        // twice (once for each edge), and we can't have three points on layer because
        // we assume this code is not getting called for horizontal facets
        assert(points_on_layer.size() == 2); // 入队的顶点一定有两个，并且相等
        assert( points[ points_on_layer[0] ].point_id == points[ points_on_layer[1] ].point_id ); 
        if (points.size() < 3) //除了顶点之外没有其他交点 直接退出
			return;  // no intersection point, this is a V-shaped facet tangent to plane
        points.erase( points.begin() + points_on_layer[1] ); // 有交点  删除重复顶点
    }
    
	// 将两个交点构成直线段，压入集合
    if (!points.empty()) 
	{
        assert(points.size() == 2); // facets must intersect each plane 0 or 2 times
        IntersectionLine line;
        line.a          = (Point)points[1];
        line.b          = (Point)points[0];
        line.a_id       = points[1].point_id;
        line.b_id       = points[0].point_id;
        line.edge_a_id  = points[1].edge_id;
        line.edge_b_id  = points[0].edge_id;
        if (lines_mutex != NULL) {
            boost::lock_guard<boost::mutex> l(*lines_mutex);
            lines->push_back(line);
        } else {
            lines->push_back(line);
        }
        return;
    }
}

//  (非实体面片  没有经过repair)计算某个三角面片和sice_z平面相交的线段 结果不带有id信息，不能make_loop
template <Axis A>
void
TriangleMeshSlicer<A>::slice_facet_nonsolid(float slice_z, const stl_facet &facet, const int &facet_idx,
	const float &min_z, const float &max_z, std::vector<IntersectionLine>* lines,
	boost::mutex* lines_mutex) const
{
	std::vector<IntersectionPoint> points;  // 在切面上交点集和
	std::vector< std::vector<IntersectionPoint>::size_type > points_on_layer;// 顶点在切平面上集合索引号
	bool found_horizontal_edge = false;

	int i = 0;
	if (_z(facet.vertex[1]) == min_z) {
		// vertex 1 has lowest Z
		i = 1;
	}
	else if (_z(facet.vertex[2]) == min_z) {
		// vertex 2 has lowest Z
		i = 2;
	}
	for (int j = i; (j - i) < 3; j++) // 遍历该面片的三条边
	{
		stl_vertex Point_a = facet.vertex[j % 3];
		stl_vertex Point_b = facet.vertex[(j + 1) % 3];
		Point_a.stl_scale(SCALING_FACTOR);
		Point_b.stl_scale(SCALING_FACTOR);
		stl_vertex* a = &Point_a;
		stl_vertex* b = &Point_b;

		if (_z(*a) == _z(*b) && _z(*a) == slice_z) // 当前边与切平面平行并且在平面上
		{
			stl_vertex Point_c = facet.vertex[(j + 2) % 3];
			Point_c.stl_scale(SCALING_FACTOR);
			stl_vertex*c = &Point_c;

			IntersectionLine line;
			if (min_z == max_z) // 当前平面是水平的
			{
				line.edge_type = feHorizontal;
				if (_z(facet.normal) < 0) // 该面片的法向量向下
				{ 
					// 如果法相点向下，这是一个底部水平面，所以我们颠倒它点的顺序
					std::swap(a, b);
				}
			}
			else if (_z(*c) < slice_z) // 另一个点在切平面之下 也要颠倒顺序
			{
				line.edge_type = feTop;
				std::swap(a, b);
			}
			else // 另一个点在切平面之上
			{
				line.edge_type = feBottom;
			}
			line.a.x = _x(*a);
			line.a.y = _y(*a);
			line.b.x = _x(*b);
			line.b.y = _y(*b);

			// 结果入栈
			if (lines_mutex != NULL)
			{
				boost::lock_guard<boost::mutex> l(*lines_mutex);
				lines->push_back(line);
			}
			else
			{
				lines->push_back(line);
			}

			found_horizontal_edge = true;

			// 如果这是顶部或底部边缘，我们可以停止在边缘上循环，因为我们不会发现任何有趣的东西
			if (line.edge_type != feHorizontal) //非水平面直接结束边循环  因为不会再有交点
				return;
		}
		else if (_z(*a) == slice_z) // 该边不是水平边  但是有个顶点在切平面上 顶点就是交点
		{
			IntersectionPoint point;
			point.x = _x(*a);
			point.y = _y(*a);
			points.push_back(point);
			points_on_layer.push_back(points.size() - 1);
		}
		else if (_z(*b) == slice_z) // 该边不是水平边  但是有个顶点在切平面上 顶点就是交点
		{
			IntersectionPoint point;
			point.x = _x(*b);
			point.y = _y(*b);
			points.push_back(point);
			points_on_layer.push_back(points.size() - 1);
		}
		else if ((_z(*a) < slice_z && _z(*b) > slice_z) || (_z(*b) < slice_z && _z(*a) > slice_z)) // 该边被切平面切割  计算交点
		{
			// edge intersects the current layer; calculate intersection
			IntersectionPoint point;
			point.x = _x(*b) + (_x(*a) - _x(*b)) * (slice_z - _z(*b)) / (_z(*a) - _z(*b));
			point.y = _y(*b) + (_y(*a) - _y(*b)) * (slice_z - _z(*b)) / (_z(*a) - _z(*b));
			points.push_back(point);
		}
	}
	// 边循环结束

	if (found_horizontal_edge)  // 发现水平边和切片面重合 退出 
		return;

	if (!points_on_layer.empty()) // 有顶点在切平面上
	{
		assert(points_on_layer.size() == 2); // 入队的顶点一定有两个，并且相等
		//assert(points[points_on_layer[0]].point_id == points[points_on_layer[1]].point_id);
		if (points.size() < 3) //除了顶点之外没有其他交点 直接退出
			return;  // no intersection point, this is a V-shaped facet tangent to plane
		points.erase(points.begin() + points_on_layer[1]); // 有交点  删除重复顶点
	}

	// 将两个交点构成直线段，压入集合
	if (!points.empty())
	{
		assert(points.size() == 2); // facets must intersect each plane 0 or 2 times
		IntersectionLine line;
		line.a = (Point)points[1];
		line.b = (Point)points[0];

		if (lines_mutex != NULL) {
			boost::lock_guard<boost::mutex> l(*lines_mutex);
			lines->push_back(line);
		}
		else {
			lines->push_back(line);
		}
		return;
	}
}

// 将所有线段围成多边形
template <Axis A>
void
TriangleMeshSlicer<A>::_make_loops_do(size_t i, std::vector<IntersectionLines>* lines, std::vector<Polygons>* layers) const
{
	LOGINFO("Layer[%d] _make_loops_do begin", i);
    this->make_loops((*lines)[i], &(*layers)[i]);
}

template <Axis A>
void
TriangleMeshSlicer<A>::make_loops(std::vector<IntersectionLine> &lines, Polygons* loops) const
{
	if (lines.size() == 0)
	{
		LOGINFO("IntersectionLine_vec size = 0");
		return;
	}
	//LOGINFO("1");
	DWORD dwStart, dwStart2, dwStart3;
	dwStart = GetTickCount();
    // 移除重复的边
    for (IntersectionLines::iterator line = lines.begin(); line != lines.end(); ++line) 
	{
        if (line->skip || line->edge_type == feNone) // 跳过已经被忽略的边
			continue;
		// 如果这条线是一个面，那就找另一个面边具有相同的端点，但以相反的顺序
        for (IntersectionLines::iterator line2 = line + 1; line2 != lines.end(); ++line2) 
		{
            if (line2->skip || line2->edge_type == feNone) // 跳过已经被忽略的边
				continue;
            
            if (line->a_id == line2->a_id && line->b_id == line2->b_id)// 两条边是同一条边 同向
			{
                line2->skip = true;
				// 如果它们都是向上或向下的(比如V)然后我们可以从这一层移除这两个边，因为它不会影响切片
				//	如果其中一个是向上的，另一个是向下的我们只保留其中一个一个因为所有的“顶”线在切片上被翻转)
                if (line->edge_type == line2->edge_type)// 在切平面上这是一条孤边
				{
                    line->skip = true;
                    break;
                }
            } 
			else if (line->a_id == line2->b_id && line->b_id == line2->a_id)// 两条边是相反的两条 
			{
				// 如果这条边连接两个横向的切面，删除它们两个
                if (line->edge_type == feHorizontal && line2->edge_type == feHorizontal) 
				{
                    line->skip = true;
                    line2->skip = true;
                    break;
                }
            }
        }
    }

	//LOGINFO("2");
	dwStart = GetTickCount() - dwStart;
	dwStart2 = GetTickCount();

	// 构建关于edge_a_id和a_id的map映射
    std::vector<IntersectionLinePtrs> by_edge_a_id, by_a_id;
	std::vector<IntersectionLinePtrs> noloop_lines; // 没有成环的lines集合
    by_edge_a_id.resize(this->mesh->stl.stats.number_of_facets * 3);
    by_a_id.resize(this->mesh->stl.stats.shared_vertices);
    for (IntersectionLines::iterator line = lines.begin(); line != lines.end(); ++line) 
	{
        if (line->skip) 
			continue;
        if (line->edge_a_id != -1) 
			by_edge_a_id[line->edge_a_id].push_back(&(*line)); // 边的索引
        if (line->a_id != -1) 
			by_a_id[line->a_id].push_back(&(*line)); // 点的索引
    }

	dwStart2 = GetTickCount() - dwStart2;
	dwStart3 = GetTickCount();
    
	//LOGINFO("3");
CYCLE: while (1) 
		{
			// 从lines容器中取出一条line
			IntersectionLine* first_line = NULL;
			for (IntersectionLines::iterator line = lines.begin(); line != lines.end(); ++line) 
			{
				if (line->skip) continue;
				first_line = &(*line);
				break;
			}
			if (first_line == NULL) break;
			first_line->skip = true; // 打上跳过标记
			IntersectionLinePtrs loop;
			loop.push_back(first_line);
        
			//LOGINFO("first_line edge_a_id = %d, edge_b_id = %d, a_id = %d, b_id = %d, a = %d,%d, b = %d,%d\n", 
			//    first_line->edge_a_id, first_line->edge_b_id, first_line->a_id, first_line->b_id,
			//    first_line->a.x, first_line->a.y, first_line->b.x, first_line->b.y);
        
			while (1)
			{
				// 取出loop中最后一条线段的b端点
				IntersectionLine* next_line = NULL;
				if (loop.back()->edge_b_id != -1) // 先从共边的线段集合中搜索临接线段
				{
					IntersectionLinePtrs &candidates = by_edge_a_id[loop.back()->edge_b_id];
					for (IntersectionLinePtrs::iterator lineptr = candidates.begin(); lineptr != candidates.end(); ++lineptr) 
					{
						if ((*lineptr)->skip) 
							continue;
						next_line = *lineptr;
						break;
					}
				}
				if (next_line == NULL && loop.back()->b_id != -1) // 如果上一步失败  从共点的线段集合中搜索临接线段
				{
					IntersectionLinePtrs &candidates = by_a_id[loop.back()->b_id];
					for (IntersectionLinePtrs::iterator lineptr = candidates.begin(); lineptr != candidates.end(); ++lineptr)
					{
						if ((*lineptr)->skip) 
							continue;
						next_line = *lineptr;
						break;
					}
				}
				// 无法找到下一条边
				if (next_line == NULL)
				{
					// loop中的线段已经闭合 
					if ((loop.front()->edge_a_id != -1 && loop.front()->edge_a_id == loop.back()->edge_b_id)
						|| (loop.front()->a_id != -1 && loop.front()->a_id == loop.back()->b_id))
					{
						// loop闭合 构造多边形Polygon
						Polygon p;
						p.points.reserve(loop.size());
						for (IntersectionLinePtrs::const_iterator lineptr = loop.begin(); lineptr != loop.end(); ++lineptr) 
						{
							p.points.push_back((*lineptr)->a);
						}
						// 记录结果
						loops->push_back(p);
						// LOGINFO("  Discovered %s polygon of %d points", (p.is_counter_clockwise() ? "ccw" : "cw"), (int)p.points.size());
					}
					else
					{
						noloop_lines.push_back(loop);
						LOGINFO("Unable to close this loop having %d points,  noloop_lines[%d]", 
							loop.size(), noloop_lines.size()-1);
					}
					
					goto CYCLE;// 下一次大循环 
				}
            
				//LOGINFO("next_line edge_a_id = %d, edge_b_id = %d, a_id = %d, b_id = %d, a = %d,%d, b = %d,%d\n", 
				//    next_line->edge_a_id, next_line->edge_b_id, next_line->a_id, next_line->b_id,
				//    next_line->a.x, next_line->a.y, next_line->b.x, next_line->b.y);
            
				// 收入当前这条线段 打上跳过标记
				loop.push_back(next_line);
				next_line->skip = true;
			}
		}
	   //异常处理 暂时不开放
	   this->make_loops_force(noloop_lines, loops);

	   dwStart3 = GetTickCount() - dwStart3;
	   LOGINFO(" 移除重复的边 耗时【%u】--- 构建map映射 耗时【%u】--- lines总数[%zu] Loops总数[%zu] 构建所有loop 耗时【%u】",
		   dwStart, dwStart2, lines.size(), loops->size(),dwStart3);
}


static bool comp_noloop_lines_size(const IntersectionLinePtrs& a, const IntersectionLinePtrs& b)
{
	return (a.size() > b.size());
}

template <Axis A>
void 
TriangleMeshSlicer<A>::make_loops_force(std::vector<IntersectionLinePtrs> &noloop_lines, Polygons* loops) const
{
	if (noloop_lines.size() == 0)
		return;

	std::sort(noloop_lines.begin(), noloop_lines.end(), comp_noloop_lines_size);
	while (noloop_lines.size())
	{
		// 取出size最大的作为major_loop
		IntersectionLinePtrs major_loop = noloop_lines.front();
		noloop_lines.erase(noloop_lines.begin());
		LOGINFO("major_loop size = %d", major_loop.size());
		std::vector<IntersectionLinePtrs>::iterator next_loops_it = noloop_lines.begin();
		while ( next_loops_it != noloop_lines.end() )
		{
			// next_loops_it头接major_loop尾
			if ((next_loops_it->front()->edge_a_id != -1 && next_loops_it->front()->edge_a_id == major_loop.back()->edge_b_id)
				|| (next_loops_it->front()->a_id != -1 && next_loops_it->front()->a_id == major_loop.back()->b_id)
				|| (next_loops_it->front()->a.coincides_with_epsilon(major_loop.back()->b)) )
			{
				major_loop.insert(major_loop.end(), next_loops_it->begin(), next_loops_it->end());
				noloop_lines.erase(next_loops_it);
				next_loops_it = noloop_lines.begin();
			}
			// next_loops_it尾接major_loop头
			else if ((next_loops_it->back()->edge_b_id != -1 && next_loops_it->back()->edge_b_id == major_loop.front()->edge_a_id)
				|| (next_loops_it->back()->b_id != -1 && next_loops_it->back()->b_id == major_loop.front()->a_id)
				|| (next_loops_it->back()->b.coincides_with_epsilon(major_loop.front()->a)) )
			{
				major_loop.insert(major_loop.begin(), next_loops_it->begin(), next_loops_it->end());
				noloop_lines.erase(next_loops_it);
				next_loops_it = noloop_lines.begin();
			}
			// next_loops_it头接major_loop头  
			else if ((next_loops_it->front()->edge_a_id != -1 && next_loops_it->front()->edge_a_id == major_loop.front()->edge_a_id)
				|| (next_loops_it->front()->a_id != -1 && next_loops_it->front()->a_id == major_loop.front()->a_id)
				|| (next_loops_it->front()->a.coincides_with_epsilon(major_loop.front()->a)) )
			{
				// next_loops_it翻转
				for (int i = 0; i < next_loops_it->size(); i++)
					next_loops_it->at(i)->reverse();
				major_loop.insert(major_loop.begin(), next_loops_it->rbegin(), next_loops_it->rend());
				noloop_lines.erase(next_loops_it);
				next_loops_it = noloop_lines.begin();
			}
			// next_loops_it尾接frist_loops尾 next_loops_it翻转
			else if ((next_loops_it->back()->edge_b_id != -1 && next_loops_it->back()->edge_b_id == major_loop.back()->edge_b_id)
				|| (next_loops_it->back()->b_id != -1 && next_loops_it->back()->b_id == major_loop.back()->b_id)
				|| (next_loops_it->back()->b.coincides_with_epsilon(major_loop.back()->b)))
			{
				// next_loops_it翻转
				for (int i = 0; i < next_loops_it->size(); i++)
					next_loops_it->at(i)->reverse();
				major_loop.insert(major_loop.end(), next_loops_it->rbegin(), next_loops_it->rend());
				noloop_lines.erase(next_loops_it);
				next_loops_it = noloop_lines.begin();
			}
			else
				next_loops_it++;
		}
		// loop中的线段已经闭合 
		if ((major_loop.front()->edge_a_id != -1 && major_loop.front()->edge_a_id == major_loop.back()->edge_b_id)
			|| (major_loop.front()->a_id != -1 && major_loop.front()->a_id == major_loop.back()->b_id)
			|| (major_loop.front()->a.coincides_with_epsilon(major_loop.back()->b)) )
		{
			// loop闭合 构造多边形Polygon
			Polygon p;
			p.points.reserve(major_loop.size());
			for (IntersectionLinePtrs::const_iterator lineptr = major_loop.begin(); lineptr != major_loop.end(); ++lineptr)
			{
				p.points.push_back((*lineptr)->a);
			}
			// 记录结果
			loops->push_back(p);
			LOGINFO("  Discovered %s polygon of %d points", (p.is_counter_clockwise() ? "ccw" : "cw"), (int)p.points.size());
		}
		else
		{
			LOGINFO("abandon this loop having %d lines",
				major_loop.size());
		}
	}
}

template <Axis A>
void
TriangleMeshSlicer<A>::make_expolygons_simple(std::vector<IntersectionLine> &lines, ExPolygons* slices) const
{
    Polygons loops;
    this->make_loops(lines, &loops);
	/*
	{
		SVG svg("lines.svg");
		svg.draw(lines, "red");
		svg.Close();
	} 
	{
		SVG svg("loops.svg");
		svg.draw(loops, "red");
		svg.Close();
	}
	*/


	LOGINFO("make_expolygons_simple 1");
    Polygons cw;
    for (Polygons::const_iterator loop = loops.begin(); loop != loops.end(); ++loop) {
        if (loop->area() >= 0) {
            ExPolygon ex;
            ex.contour = *loop;
            slices->push_back(ex);
        } else {
            cw.push_back(*loop);
        }
    }
    
	LOGINFO("make_expolygons_simple 2");
    // assign holes to contours
    for (Polygons::const_iterator loop = cw.begin(); loop != cw.end(); ++loop) {
        int slice_idx = -1;
        double current_contour_area = -1;
        for (ExPolygons::iterator ex_slice = slices->begin(); ex_slice != slices->end(); ++ex_slice) {
            if (ex_slice->contour.contains(loop->points.front())) {
                double area = ex_slice->contour.area();
                if (area < current_contour_area || current_contour_area == -1) {
                    slice_idx = ex_slice - slices->begin();
                    current_contour_area = area;
                }
            }
        }
		if (slice_idx != -1)
			(*slices)[slice_idx].holes.push_back(*loop);
		else
			LOGINFO("hole can not find contour contains!");
    }
	LOGINFO("make_expolygons_simple 3");
}

template <Axis A>
void
TriangleMeshSlicer<A>::_make_expolygons_do( size_t i, std::vector<Polygons>* layers_p, std::vector<ExPolygons>* layers_ex ) const
{
	LOGINFO("[%zu] make_expolygons Layer 开始" , i);
	DWORD dwStart = GetTickCount();
	this->make_expolygons( (*layers_p)[i], &(*layers_ex)[i]);
	LOGINFO("[%zu] make_expolygons Layer  耗时【%u】", i, GetTickCount() - dwStart);
}


// 将Polygons转化为ExPolygons
template <Axis A>
void
TriangleMeshSlicer<A>::make_expolygons(const Polygons &loops, ExPolygons* slices) const
{
	TriangleMesh::make_expolygons(loops, slices, false);
}


//  将交线集合转化为ExPolygons
template <Axis A>
void
TriangleMeshSlicer<A>::make_expolygons(std::vector<IntersectionLine> &lines, ExPolygons* slices) const
{
    Polygons pp;
    this->make_loops(lines, &pp);
    this->make_expolygons(pp, slices);
}

template <Axis A>
void
TriangleMeshSlicer<A>::cut(float z, TriangleMesh* upper, TriangleMesh* lower) const
{
	LOGINFO("cutting begin cut z = %f", z);
    IntersectionLines upper_lines, lower_lines;
    
    const float scaled_z = scale_(z);
    for (int facet_idx = 0; facet_idx < this->mesh->stl.stats.number_of_facets; facet_idx++) {
        stl_facet* facet = &this->mesh->stl.facet_start[facet_idx];
        
        // find facet extents
        float min_z = fminf(_z(facet->vertex[0]), fminf(_z(facet->vertex[1]), _z(facet->vertex[2])));
        float max_z = fmaxf(_z(facet->vertex[0]), fmaxf(_z(facet->vertex[1]), _z(facet->vertex[2])));
        
        // intersect facet with cutting plane
        IntersectionLines lines;
        this->slice_facet(scaled_z, *facet, facet_idx, min_z, max_z, &lines);
        
        // save intersection lines for generating correct triangulations
        for (IntersectionLines::const_iterator it = lines.begin(); it != lines.end(); ++it) {
            if (it->edge_type == feTop) {
                lower_lines.push_back(*it);
            } else if (it->edge_type == feBottom) {
                upper_lines.push_back(*it);
            } else if (it->edge_type != feHorizontal) {
                lower_lines.push_back(*it);
                upper_lines.push_back(*it);
            }
        }
        
        if (min_z > z || (min_z == z && max_z > min_z)) {
            // facet is above the cut plane and does not belong to it
            if (upper != NULL) stl_add_facet(&upper->stl, facet);
        } else if (max_z < z || (max_z == z && max_z > min_z)) {
            // facet is below the cut plane and does not belong to it
            if (lower != NULL) stl_add_facet(&lower->stl, facet);
        } else if (min_z < z && max_z > z) {
            // facet is cut by the slicing plane
            
            // look for the vertex on whose side of the slicing plane there are no other vertices
            int isolated_vertex;
            if ( (_z(facet->vertex[0]) > z) == (_z(facet->vertex[1]) > z) ) {
                isolated_vertex = 2;
            } else if ( (_z(facet->vertex[1]) > z) == (_z(facet->vertex[2]) > z) ) {
                isolated_vertex = 0;
            } else {
                isolated_vertex = 1;
            }
            
            // get vertices starting from the isolated one
            stl_vertex* v0 = &facet->vertex[isolated_vertex];
            stl_vertex* v1 = &facet->vertex[(isolated_vertex+1) % 3];
            stl_vertex* v2 = &facet->vertex[(isolated_vertex+2) % 3];
            
            // intersect v0-v1 and v2-v0 with cutting plane and make new vertices
            stl_vertex v0v1, v2v0;
            _x(v0v1) = _x(*v1) + (_x(*v0) - _x(*v1)) * (z - _z(*v1)) / (_z(*v0) - _z(*v1));
            _y(v0v1) = _y(*v1) + (_y(*v0) - _y(*v1)) * (z - _z(*v1)) / (_z(*v0) - _z(*v1));
            _z(v0v1) = z;
            _x(v2v0) = _x(*v2) + (_x(*v0) - _x(*v2)) * (z - _z(*v2)) / (_z(*v0) - _z(*v2));
            _y(v2v0) = _y(*v2) + (_y(*v0) - _y(*v2)) * (z - _z(*v2)) / (_z(*v0) - _z(*v2));
            _z(v2v0) = z;
            
            // build the triangular facet
            stl_facet triangle;
            triangle.normal = facet->normal;
            triangle.vertex[0] = *v0;
            triangle.vertex[1] = v0v1;
            triangle.vertex[2] = v2v0;
            
            // build the facets forming a quadrilateral on the other side
            stl_facet quadrilateral[2];
            quadrilateral[0].normal = facet->normal;
            quadrilateral[0].vertex[0] = *v1;
            quadrilateral[0].vertex[1] = *v2;
            quadrilateral[0].vertex[2] = v0v1;
            quadrilateral[1].normal = facet->normal;
            quadrilateral[1].vertex[0] = *v2;
            quadrilateral[1].vertex[1] = v2v0;
            quadrilateral[1].vertex[2] = v0v1;
            
            if (_z(*v0) > z) {
                if (upper != NULL) stl_add_facet(&upper->stl, &triangle);
                if (lower != NULL) {
                    stl_add_facet(&lower->stl, &quadrilateral[0]);
                    stl_add_facet(&lower->stl, &quadrilateral[1]);
                }
            } else {
                if (upper != NULL) {
                    stl_add_facet(&upper->stl, &quadrilateral[0]);
                    stl_add_facet(&upper->stl, &quadrilateral[1]);
                }
                if (lower != NULL) stl_add_facet(&lower->stl, &triangle);
            }
        }
    }
    
    // triangulate holes of upper mesh
    if (upper != NULL) {
		LOGINFO("Cutting upper 1");
        // compute shape of section
        ExPolygons section;
        this->make_expolygons_simple(upper_lines, &section);
        
		LOGINFO("Cutting upper 2");
        // triangulate section
        Polygons triangles;
        for (ExPolygons::const_iterator expolygon = section.begin(); expolygon != section.end(); ++expolygon)
            expolygon->triangulate_p2t(&triangles);
        
		LOGINFO("Cutting upper 3");
        // convert triangles to facets and append them to mesh
        for (Polygons::const_iterator polygon = triangles.begin(); polygon != triangles.end(); ++polygon) {
            Polygon p = *polygon;
            p.reverse();
            stl_facet facet;
            _x(facet.normal) = 0;
            _y(facet.normal) = 0;
            _z(facet.normal) = -1;
            for (size_t i = 0; i <= 2; ++i) {
                _x(facet.vertex[i]) = unscale(p.points[i].x);
                _y(facet.vertex[i]) = unscale(p.points[i].y);
                _z(facet.vertex[i]) = z;
            }
            stl_add_facet(&upper->stl, &facet);
        }
		LOGINFO("Cutting upper 4");
    }
    
    // triangulate holes of lower mesh
    if (lower != NULL) {
		LOGINFO("Cutting lower 1");
        // compute shape of section
        ExPolygons section;
        this->make_expolygons_simple(lower_lines, &section);
        
		LOGINFO("Cutting lower 2");
        // triangulate section
        Polygons triangles;
        for (ExPolygons::const_iterator expolygon = section.begin(); expolygon != section.end(); ++expolygon)
            expolygon->triangulate_p2t(&triangles);
        
		LOGINFO("Cutting lower 3");
        // convert triangles to facets and append them to mesh
        for (Polygons::const_iterator polygon = triangles.begin(); polygon != triangles.end(); ++polygon) {
            stl_facet facet;
            _x(facet.normal) = 0;
            _y(facet.normal) = 0;
            _z(facet.normal) = 1;
            for (size_t i = 0; i <= 2; ++i) {
                _x(facet.vertex[i]) = unscale(polygon->points[i].x);
                _y(facet.vertex[i]) = unscale(polygon->points[i].y);
                _z(facet.vertex[i]) = z;
            }
            stl_add_facet(&lower->stl, &facet);
        }
		LOGINFO("Cutting lower 4");
    }
    
    stl_get_size(&(upper->stl));
    stl_get_size(&(lower->stl));
	LOGINFO("Cutting Finish");
}

template <Axis A>
TriangleMeshSlicer<A>::TriangleMeshSlicer(TriangleMesh* _mesh) : mesh(_mesh), v_scaled_shared(NULL)
{
	this->worker_p = NULL;
	this->worker_pp = &(this->worker_p);
	this->is_nonsolid = this->mesh->checkonly;

	// 非实体mesh切割不做require_shared_vertices，否则会死循环
	if (is_nonsolid) return;

    // build a table to map a facet_idx to its three edge indices
    this->mesh->require_shared_vertices();
    typedef std::pair<int,int>              t_edge;
    typedef std::vector<t_edge>         t_edges;           // edge_idx => a_id,b_id
    typedef std::map<t_edge,int>       t_edges_map;  // a_id,b_id => edge_idx
    
    this->facets_edges.resize(this->mesh->stl.stats.number_of_facets);
	LOGINFO("t_edges edges;");
    {
        t_edges edges;
        // reserve() instad of resize() because otherwise we couldn't read .size() below to assign edge_idx
        edges.reserve(this->mesh->stl.stats.number_of_facets * 3);  // number of edges = number of facets * 3
        t_edges_map edges_map;
        for (int facet_idx = 0; facet_idx < this->mesh->stl.stats.number_of_facets; facet_idx++) {
			//LOGINFO("facet_idx = %d, number_of_facets = %d", facet_idx, this->mesh->stl.stats.number_of_facets);
            this->facets_edges[facet_idx].resize(3);
            for (int i = 0; i <= 2; i++) {
				//LOGINFO("facet_idx step 1 i =[%d]", facet_idx, i);

                int a_id = this->mesh->stl.v_indices[facet_idx].vertex[i];
                int b_id = this->mesh->stl.v_indices[facet_idx].vertex[(i+1) % 3];
				//LOGINFO("facet_idx step 2 i =[%d]", facet_idx, i);
                int edge_idx;
                t_edges_map::const_iterator my_edge = edges_map.find(std::make_pair(b_id,a_id));
                if (my_edge != edges_map.end()) {
                    edge_idx = my_edge->second;
                } else {
                    /* admesh can assign the same edge ID to more than two facets (which is 
                       still topologically correct), so we have to search for a duplicate of 
                       this edge too in case it was already seen in this orientation */
                    my_edge = edges_map.find(std::make_pair(a_id,b_id));
                    
                    if (my_edge != edges_map.end()) {
                        edge_idx = my_edge->second;
                    } else {
                        // edge isn't listed in table, so we insert it
                        edge_idx = edges.size();
                        edges.push_back(std::make_pair(a_id,b_id));						
                        edges_map[ edges[edge_idx] ] = edge_idx;
                    }
                }
				
                this->facets_edges[facet_idx][i] = edge_idx;
                //LOGINFO("  [facet %d, edge %d] a_id = %d, b_id = %d   --> edge %d", facet_idx, i, a_id, b_id, edge_idx);
            }
        }
    }
    
	LOGINFO("std::copy");
    // clone shared vertices coordinates and scale them
    this->v_scaled_shared = (stl_vertex*)calloc(this->mesh->stl.stats.shared_vertices, sizeof(stl_vertex));
    std::copy(this->mesh->stl.v_shared, this->mesh->stl.v_shared + this->mesh->stl.stats.shared_vertices, this->v_scaled_shared);
    for (int i = 0; i < this->mesh->stl.stats.shared_vertices; i++) {
		this->v_scaled_shared[i].stl_scale(SCALING_FACTOR);
    }
}

template <Axis A>
TriangleMeshSlicer<A>::~TriangleMeshSlicer()
{
    if (this->v_scaled_shared != NULL) free(this->v_scaled_shared);
}

template class TriangleMeshSlicer<X>;
template class TriangleMeshSlicer<Y>;
template class TriangleMeshSlicer<Z>;

}